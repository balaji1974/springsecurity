# Spring Security  
## Basics of Security in Spring  
### Authentication Filter will call ->  Authentication Manager will call -> Authentication Provider will call -> User Detail Service and Password Encoder  
### Authentication Filter -> has the security context that has both Authentication Success Handler and Authentication Failure Handler  

## 1. Simple basic security (Project name: basic-security)  

a. To enable security in spring all we need to do is add the following dependency in our pom.xml file 
```xml  
<dependency>  
	<groupId>org.springframework.boot</groupId>  
	<artifactId>spring-boot-starter-security</artifactId>  
</dependency>  
```  

b. When we start the server we will get a "Using generated security password:". This is the autogenerated password which keeps changing on every server startup.  

c. When we access any resource from the server all we need to do is use the default user name "user" and the auto generated password when the server starts up.  

## 2. In-Memory Security (Project name: inmemory-security)   

a. The above security cannot be used for real time senarios and hence we move to our next type which is the custom in-memory security.    

b. For this we need to extend a Configuration class with WebSecurityConfigurerAdapter and then over ride the two configure methods.   

c. We also need to inject a bean for password encoder bean which is mandatory in Spring security now.  

## 3. Custom Authentication Provider (Project name: custom-authentication-security)  

a. Create a spring component class called CustomAuthenticaionProvider and implements org.springframework.security.authentication.AuthenticationProvider  

b. Override the following 2 methods:  
public Authentication authenticate(Authentication authentication) throws AuthenticationException {}  
public boolean supports(Class<?> authentication) {}  

c. Check code for details of implementation of these methods.  

## 4. Multiple Authentication Providers (Project name: multiple-authentication-security)  

a. Often we will have situations where we will have more than one way in which the user needs to be authenticated into the application. So we need to provide Spring security with multiple ways in which we can authenticate our users.  

b. This project is a combination of 2 and 3 steps described above.    
Only change is in the protected void configure(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {}  method used in SecurityConfiguration file where we add our 2 authentication builders as below:    
authenticationManagerBuilder.authenticationProvider(customAuthenticationProvider);   
authenticationManagerBuilder.inMemoryAuthentication().withUser("b1").password(passwordEncoder.encode("b1")).roles("USER");    

c. The order of authentication checking will be the order in which we provide the Spring AuthenticationManagerBuilder our different methods of Authentication.   

## 5. Form based authentication (Project name: form-based-security)    
a. For form based authentication do the following in the configure method of the class extending the WebSecurityConfigurerAdapter     
httpSecurity.httpBasic() > Replace with  -> httpSecurity.formLogin();    

b. Now you will be presented with a login form automatically and once you login you will be redirected to the requested resource.   


## 6. Security Filters and Mulitple Spring boot security configurations (REST/WEB in same application) (Project name: spring-security-filter)   
a. For adding security filter all we need to do is add a class that impletements the Filter interface - eg. UsernamePasswordAuthenticationFilter, GenericFilterBean, OncePerRequestFilter etc.   

b. Here we can add anything related to security like  additional "http headers" or any other information that is needed before/after the request gets processed.   

c. In this example I have shown how to implement mulitple spring boot security configurations and ordering them using the @Order annotation. In this way we can clearly segreggate our REST apis from our web apis.   

d. I have added additional depenedency for my web page    
```xml   
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency> 
<dependency>
	<groupId>org.thymeleaf.extras</groupId>
	<artifactId>thymeleaf-extras-springsecurity5</artifactId>
</dependency>
```   

e. I have added mulitple controllers, multiple security filters and multiple spring security configurations for both web and rest api based requests.   
All WEB request will now have the path /web/** and all API request will follow the path /api/**    

f. Also note that by adding the GenericFilterBean instead of Filter interface we can inject variables from our web.xml file using getters and setter properties.       

## 7. Multiple Password Encoders (Project name: spring-security-passwordencoders)   
a. I have added additional depenedency for support of SCryptPasswordEncoder     
```xml   
<dependency>
    <groupId>org.bouncycastle</groupId>
    <artifactId>bcprov-jdk15on</artifactId>
    <version>1.68</version>
</dependency>
```   

b. I have created a password encoder configuration class that supports 4 different types of password encoding based on the parameter that is set in application.properties file in the variable password.encoder   

c. I have also created a DelegatingPasswordEncoder as a default configuration and this takes its parameter from the DEFAULT_PASSWORD_ENCODER variable.   

d. In this way you can enhance your spring application to support multiple types of password encodings.   

## 8. Database Authenication Provider (Project name: database-authentication-provider)   
a. I have added additional depenedency for support H2 Database and Spring Data JPA over the already existing dependencies before.     
```xml   
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
	<scope>runtime</scope>
</dependency>
```  

b. In the application.properties file add the following properties to enable h2 console and hibernate statistics:   
pring.h2.console.enabled=true    
spring.datasource.url=jdbc:h2:mem:testdb    
&nbsp;    
spring.jpa.properties.hibernate.generate_statistics=true    
logging.level.org.hibernate.stat=debug    
&nbsp;    
spring.jpa.show-sql=true   
spring.jpa.properties.hibernate.format_sql=true   
logging.level.org.hibernate.type=trace    

c. In the WebSecurity configuration add the addition antmatchers to enable h2 console url access from the browser without authentication for now:    
.antMatchers("/h2-console/\*\*").permitAll()   // never do this in production environment  
Also add the following 2 lines for the console to be accessed from the browser:   
httpSecurity.csrf().disable();    
httpSecurity.headers().frameOptions().disable();    

d. Add data.sql in the resource folder which will auto create the intitial database insert scripts once the server starts up.    

e. Start the server and check the following url to see if the h2 console is working fine.   
http://localhost:8080/h2-console/    

f. Now using spring data JPA concepts create Entities called User and Role. The User and Role are mapped to each other using ManyToMany mapping and it is specified both at the user and role entity class as follows:    
In User Table:     
@ManyToMany(fetch=FetchType.EAGER)   
@JoinTable(   
&nbsp;&nbsp;&nbsp;name = "user_role",   
&nbsp;&nbsp;&nbsp;joinColumns = @JoinColumn(name = "user_id"),   
&nbsp;&nbsp;&nbsp;inverseJoinColumns = @JoinColumn(name = "role_id")   
)   
private List<Role> roles;   


And in the role table as:     
@ManyToMany(mappedBy="roles")   
private List<User> users;    

The role table also implements the GrantedAuthority interface and overrides the method getAuthority as follows:   

@Override   
public String getAuthority() {   
&nbsp;&nbsp;&nbsp;return name;   
}    

g. Now create spring repository interface for these two entities by extending the JpaRepository. In the UserRepository interface add the following additional method.   
User findByUsername(String username);    

h. Next create a service method called UserDetailsServiceImpl which implements the org.springframework.security.core.userdetails.UserDetailsService.   
Now override the method called loadUserByUsername that takes the username as input and returns the org.springframework.security.core.userdetails.UserDetails.   

i. Next all we need to do is inject this UserDetailService implemenation class into our WebSecurityConfiguration class and add it in the configure method as:    
authenticationManagerBuilder.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);      

We are now good to go and the application has now, one more method of authentication which is from the database.    

### 9. Custom Login Page (Project name: custom-login-service)   
a. In this project I have implemented our own custom login page, but before that I cleaned up the code to remove multiple authentication managers and left only the database authentication method for simplicity.   

b. We need to implement a SecurityServiceImpl with one default method for login which accepts username and password.   

c. Inside this method we can load our previously created UserDetailService and get the userdetails and pass it to the UsernamePasswordAuthenticationToken to get an authentication token.   

d. Next we need to pass this authentication token to the spring's authentication manager which we need to expose as a bean from our WebSecurityConfiguration    

e. Finally if the token is authenticated we set this authentication manually ourselves inside the SecurityContextHolder and return the boolean result of the token's authentication status.    

f. Based on this return value our controller can map to the main page or back to the login page if the authentication fails.    

g. We must not forget to add all our newly created pages to the antMatchers to be either authorized or to permit them without authorization.    


### 10. Creating an authorization server for my microservices using JWT authentication token (Project name: authentication-service)
```xml
1. Create the following dependencies
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-devtools</artifactId>
	<scope>runtime</scope>
	<optional>true</optional>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
<dependency>
	<groupId>javax.xml.bind</groupId>
	<artifactId>jaxb-api</artifactId>
</dependency>
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
	<scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

2. Add the following in the application.properties
#secret key - should be encrypted
sec.app.jwtSecret=mysecrectkey
# validity is for 30 days - which will be the default if not passed during creation time 
sec.app.jwtExpirationMs=2592000000


## Local Connection 
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/servicesecurity
spring.datasource.username=security-user
#change this pwd later
spring.datasource.password=secusr$1$2
spring.jpa.hibernate.ddl-auto=update
# to uncomment this line for inserting the initial data from data.sql
# spring.datasource.initialization-mode=always


# For error handling
server.error.include-stacktrace=ON_PARAM
spring.mvc.throw-exception-if-no-handler-found=true
spring.web.resources.add-mappings=false

3. REST services users are created from rest end point /api/auth//signup

4. Login in performed from the endpoint /api/auth/login

5. After login a JWT token is created and added to the response body which can be used by other sevices to validate the token and 
allow access.

6. The token is created with validity and roles that are authroized which can be easily decoded by other services using the same 
token that was used for generating the token 

7. A sample Postmap json is added for testing and sample data.sql file is given for ease of initial inserts. 

8. Futher details of how other services can use this token will be given in the below example. 


```

## Using HashiCorp Vault (vault-demo) 
```xml   
Install and start vault - Create a compose.yaml file with the following config:
services:
  vault:
    container_name: "guide-vault"
    image: hashicorp/vault:latest
    environment:
      VAULT_DEV_ROOT_TOKEN_ID: "00000000-0000-0000-0000-000000000000"
    ports:
      - "8200:8200"

Next start the container by using:
docker compose up 

Once the container starts connect to the running Docker container with the command:
docker exec -it guide-vault sh

You are now running commands inside of the HashiCorp Vault container.
First, you need to set two environment variables to point the Vault CLI 
to the Vault endpoint and provide an authentication token.
export VAULT_TOKEN="00000000-0000-0000-0000-000000000000"
export VAULT_ADDR="http://127.0.0.1:8200"

Now you can store configuration key-value pairs inside Vault. 
In this example, you store two key-value pairs:
vault kv put secret/gs-vault-config example.username=demouser example.password=demopassword
vault kv put secret/gs-vault-config/cloud example.username=clouduser example.password=cloudpassword

Now you have written two entries in Vault secret/gs-vault-config and secret/gs-vault-config/cloud

The running vault container can be accessed from the URL:
http://127.0.0.1:8200
Login Method: Token
Token: 00000000-0000-0000-0000-000000000000

Now from the Spring Initilizer add the following 2 dependencies 
and download and import the project:
Web
DevTools
Vault Config

Your pom.xml file will have the following dependencies:
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-vault-config</artifactId>
</dependency>

Add one more additional dependency for adding and reading key-values into vault
<dependency>
    <groupId>org.springframework.vault</groupId>
    <artifactId>spring-vault-core</artifactId>
</dependency>

Next in the application.properties file add the following value:
spring.cloud.vault.uri=http://127.0.0.1:8200
spring.cloud.vault.token=00000000-0000-0000-0000-000000000000
spring.cloud.vault.scheme=http
spring.cloud.vault.kv.enabled=true
spring.cloud.vault.kv.backend=secret
spring.cloud.vault.kv.default-context=gs-vault-config

Next create a VaultService class to read and 
write values to Vault using the VaultTemplate
@Service
public class VaultService {
    @Autowired
    private VaultTemplate vaultTemplate;
    
    public void writeSecret(String path, Map<String, String> secrets) {
        VaultKeyValueOperations operations = vaultTemplate.opsForKeyValue("secret", VaultKeyValueOperationsSupport.KeyValueBackend.KV_2);
        operations.put(path, secrets);
    }
   
    public Map<String, Object> readSecret(String path) {
        VaultResponse response = vaultTemplate.opsForKeyValue("secret", VaultKeyValueOperationsSupport.KeyValueBackend.KV_2).get(path);
        return response.getData();
    }
}

Next in the main application class, VaultDemoApplication implement command runner 
and test the application:
@SpringBootApplication
public class VaultDemoApplication implements CommandLineRunner{
	
	@Autowired
    private VaultService vaultService;
	
	@Autowired
	private VaultTemplate vaultTemplate;

	public static void main(String[] args) {
		SpringApplication.run(VaultDemoApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		// Write into vault
		Map<String, String> secrets = new HashMap<>();
        secrets.put("apiKey", "12345");
        secrets.put("apiSecret", "67890");
        vaultService.writeSecret("api/credentials", secrets);
		
        //Read the values written
		Map<String, Object> readSecrets = vaultService.readSecret("api/credentials");
        System.out.println("Read Secrets: " + readSecrets);
        
        // Read key-value pair already inside vault
        readSecrets = vaultService.readSecret("gs-vault-config");
        System.out.println("Read Secrets: " + readSecrets);
		
        
        // Another way to read
        VaultResponse response = vaultTemplate
                .opsForKeyValue("secret", KeyValueBackend.KV_2).get("gs-vault-config");
        System.out.println("Value of gs-vault-config");
        System.out.println("-------------------------------");
        System.out.println(response.getData().get("example.username"));
        System.out.println(response.getData().get("example.password"));
        System.out.println("-------------------------------");
        System.out.println();
        
        
        // Let's encrypt some data using the Transit backend.
        VaultTransitOperations transitOperations = vaultTemplate.opsForTransit();

        // We need to setup transit first (assuming you didn't set up it yet).
        VaultSysOperations sysOperations = vaultTemplate.opsForSys();

        if (!sysOperations.getMounts().containsKey("transit/")) {

          sysOperations.mount("transit", VaultMount.create("transit"));

          transitOperations.createKey("foo-key");
        }

        // Encrypt a plain-text value
        String ciphertext = transitOperations.encrypt("foo-key", "Secure message");

        System.out.println("Encrypted value");
        System.out.println("-------------------------------");
        System.out.println(ciphertext);
        System.out.println("-------------------------------");
        System.out.println();

        // Decrypt

        String plaintext = transitOperations.decrypt("foo-key", ciphertext);

        System.out.println("Decrypted value");
        System.out.println("-------------------------------");
        System.out.println(plaintext);
        System.out.println("-------------------------------");
        System.out.println();
	}

}

```

## Using HashiCorp Vault (another-vault-demo) 
```xml  
Another Vault Demo is a client application that can connect to vault and fetch secrets.
To check this please follow the below step.

Make sure that the vault server is started (as per previous example)
or else start the container as per the previous example 

Once the container starts connect to the running Docker container with the command:
docker exec -it guide-vault sh

You are now running commands inside of the HashiCorp Vault container.
First, you need to set two environment variables to point the Vault CLI 
to the Vault endpoint and provide an authentication token.
export VAULT_TOKEN="00000000-0000-0000-0000-000000000000"
export VAULT_ADDR="http://127.0.0.1:8200"

Now you can store configuration key-value pairs inside Vault. 
In this example, you store user name and password as key-value pairs inside Vault:
vault kv put secret/another-vault-demo database.username=demouser database.password=demopassword

Note: the secret/anther-valut-demo (is the application name)

Next create a spring project with the following dependencies:
Web
DevTools
Vault config

Download the project and load into your IDE. 
You will see the following main dependency in your pom.xml file:
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-vault-config</artifactId>
</dependency>

Next in the application.properties use the following config
to connect to the server:
spring.cloud.vault.uri=http://localhost:8200
spring.cloud.vault.authentication=TOKEN
spring.cloud.vault.token=00000000-0000-0000-0000-000000000000
spring.config.import=vault://

Next create a component class to read the secrets from the vault
using the @Value property and print it. 

@Component
public class DbConfig {
	@Value("${database.password}")
    private String dbPassword;
	
	@Value("${database.username}")
    private String userName;
	
	@PostConstruct
    public void init() {
        // Initialization logic after construction and dependency injection
        System.out.println("DbConfig bean initialized!");
        System.out.println(userName);
        System.out.println(dbPassword);
    }	
}

Run the program to see the secret being read from Vault 
and printed onto the console.


Note: ### The above 2 examples use vault in-memory mode and 
all secrets are lost when the server restarts. To prevent this use vault 
with persistent storage. 
Using a database secret backend requires to enable the backend in the configuration 
and the spring-cloud-vault-config-databases dependency.
More details can be got from here:
https://docs.spring.io/spring-cloud-vault/docs/current/reference/html/#vault.config.backends.database-backends


```


### 11. Preventing ButeForce Attack using spring security 
https://www.baeldung.com/spring-security-block-brute-force-authentication-attempts


### 12. Preventing DDoS Attacks in spring security using additional libriaries 
https://stackoverflow.com/questions/39634868/restrict-access-to-public-service-many-times
https://bucket4j.com/
https://github.com/shlomokoren/spring-boot-throttling



References:
https://spring.io/guides/gs/securing-web/
https://www.bezkoder.com/spring-boot-jwt-authentication/
https://jwt.io/
https://www.epochconverter.com/
https://developer.hashicorp.com/vault/tutorials/get-started/install-binary
https://spring.io/guides/gs/vault-config






